const {
  GraphQLObjectType,
  GraphQLBoolean,
  GraphQLString,
  GraphQLInt,
  GraphQLFloat,
  GraphQLList,
  GraphQLListType,
  GraphQLJSON,
  GraphQLInputObjectType
} = require('graphql');
const fs = require(`fs-extra`);
const path = require(`path`);
const graphQLJSON = require(`graphql-type-json`);

module.exports = ({ type, getNodeAndSavePathDependency, pathPrefix = `` }) => {
  console.log(type.name);
  if (type.name !== `FigmaDOCUMENT`) {
    return {};
  }

  return {
    pages: {
      name: `Pages`,
      type: new GraphQLList(new GraphQLObjectType({
        name: `Page`,
        fields: () => {
          return {
            name: { type: GraphQLString },
            id: { type: GraphQLString },
            type: { type: GraphQLString },
            backgroundColor: {
              type: new GraphQLObjectType({
                name: `backgroundColor`,
                fields: () => ({
                  r: { type: GraphQLFloat },
                  g: { type: GraphQLFloat },
                  b: { type: GraphQLFloat },
                  a: { type: GraphQLInt }
                })
              })
            }
          };
        }
      })),
      args: {
        name: {
          type: new GraphQLInputObjectType({
            name: `PageNameEquals`,
            fields: () => ({
              eq: { type: GraphQLString },
              regex: { type: GraphQLString }
            })
          })
        }
      },
      description: `Copy file to static directory and return public url to it`,
      resolve: (file, { name }, context) => {
        let { pages } = file;

        if (name.eq) {
          pages = pages.filter(page => page.name == name.eq);
        }

        if (name.regex) {
          function last(array) {
            const length = array == null ? 0 : array.length;
            return length ? array[length - 1] : undefined;
          }

          const prepare = str => {
            const exploded = str.split(`/`);
            const regex = new RegExp(exploded.slice(1, -1).join(`/`), last(exploded));
            return regex;
          };

          pages = pages.filter(page => prepare(name.regex).exec(page.name) !== null);
        }

        // Filter by name
        return pages;
      }
    }
  };
};